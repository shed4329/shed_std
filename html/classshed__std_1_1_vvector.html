<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>shed_std: shed_std::Vvector&lt; E &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">shed_std
   </div>
   <div id="projectbrief">0.08</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classshed__std_1_1_vvector.html','','classshed__std_1_1_vvector-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">shed_std::Vvector&lt; E &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:Vvector_5Fconst_5Fiterator" id="r_Vvector_5Fconst_5Fiterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a></td></tr>
<tr class="memitem:Vvector_5Fiterator" id="r_Vvector_5Fiterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1df73caad3ea86020739e3b94966f64d" id="r_a1df73caad3ea86020739e3b94966f64d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1df73caad3ea86020739e3b94966f64d">Vvector</a> ()</td></tr>
<tr class="memitem:a7ded0433c63951b60e1f7e631e6266a6" id="r_a7ded0433c63951b60e1f7e631e6266a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ded0433c63951b60e1f7e631e6266a6">Vvector</a> (int <a class="el" href="#a160da0dcb165bd9d9ad55087475bf058">size</a>)</td></tr>
<tr class="memitem:a28f39db5d9b1872bfa890646ed790c25" id="r_a28f39db5d9b1872bfa890646ed790c25"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28f39db5d9b1872bfa890646ed790c25">Vvector</a> (const <a class="el" href="classshed__std_1_1_vvector.html">Vvector</a> &amp;other)</td></tr>
<tr class="memitem:ae0a64b9bb2e5f7b90d31731068bd5f69" id="r_ae0a64b9bb2e5f7b90d31731068bd5f69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector.html">Vvector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0a64b9bb2e5f7b90d31731068bd5f69">operator=</a> (const <a class="el" href="classshed__std_1_1_vvector.html">Vvector</a> &amp;other)</td></tr>
<tr class="memitem:a94aad920b5c4b71811c320ba034daf22" id="r_a94aad920b5c4b71811c320ba034daf22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94aad920b5c4b71811c320ba034daf22">operator==</a> (const <a class="el" href="classshed__std_1_1_vvector.html">Vvector</a> &amp;other) const</td></tr>
<tr class="memitem:adf4e4936727270e0268586c52e9a8cce" id="r_adf4e4936727270e0268586c52e9a8cce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf4e4936727270e0268586c52e9a8cce">operator!=</a> (const <a class="el" href="classshed__std_1_1_vvector.html">Vvector</a> &amp;other) const</td></tr>
<tr class="memitem:ab9bb04adafdc30099a2f15631412a298" id="r_ab9bb04adafdc30099a2f15631412a298"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9bb04adafdc30099a2f15631412a298">length</a> () const</td></tr>
<tr class="memitem:a160da0dcb165bd9d9ad55087475bf058" id="r_a160da0dcb165bd9d9ad55087475bf058"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a160da0dcb165bd9d9ad55087475bf058">size</a> () const</td></tr>
<tr class="memitem:a9cbfff4c78733c9d8ed344d67ba05ff3" id="r_a9cbfff4c78733c9d8ed344d67ba05ff3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cbfff4c78733c9d8ed344d67ba05ff3">empty</a> () const</td></tr>
<tr class="memitem:a472021ddaf9d30846eb9bcb6748a3a69" id="r_a472021ddaf9d30846eb9bcb6748a3a69"><td class="memItemLeft" align="right" valign="top">E &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a472021ddaf9d30846eb9bcb6748a3a69">at</a> (int index)</td></tr>
<tr class="memitem:ab3f587b849248c5cd5eb75450f8b95ea" id="r_ab3f587b849248c5cd5eb75450f8b95ea"><td class="memItemLeft" align="right" valign="top">const E &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3f587b849248c5cd5eb75450f8b95ea">at</a> (int index) const</td></tr>
<tr class="memitem:a357f3abc44bd9e9b144c0ab863a9477d" id="r_a357f3abc44bd9e9b144c0ab863a9477d"><td class="memItemLeft" align="right" valign="top">E &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a357f3abc44bd9e9b144c0ab863a9477d">operator[]</a> (int index)</td></tr>
<tr class="memitem:abf353f85d6aeac8750984de1e42913a2" id="r_abf353f85d6aeac8750984de1e42913a2"><td class="memItemLeft" align="right" valign="top">const E &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf353f85d6aeac8750984de1e42913a2">operator[]</a> (int index) const</td></tr>
<tr class="memitem:ace27eda10aa4ead8ee5165c2f6d4f274" id="r_ace27eda10aa4ead8ee5165c2f6d4f274"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace27eda10aa4ead8ee5165c2f6d4f274">push_back</a> (const E &amp;value)</td></tr>
<tr class="memitem:ad40c6b217d7b63432343d7fcbd681b5f" id="r_ad40c6b217d7b63432343d7fcbd681b5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad40c6b217d7b63432343d7fcbd681b5f">pop_back</a> ()</td></tr>
<tr class="memitem:a46cbb72fb31897c8b0dea0e53b6ee8a8" id="r_a46cbb72fb31897c8b0dea0e53b6ee8a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46cbb72fb31897c8b0dea0e53b6ee8a8">insert</a> (int index, const E &amp;value)</td></tr>
<tr class="memitem:a949e8dbdd10ffa2cf3539e8049a65f90" id="r_a949e8dbdd10ffa2cf3539e8049a65f90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a949e8dbdd10ffa2cf3539e8049a65f90">erase</a> (int index)</td></tr>
<tr class="memitem:a46262d3a57cd6c4b701af8fd7332372c" id="r_a46262d3a57cd6c4b701af8fd7332372c"><td class="memItemLeft" align="right" valign="top">E &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46262d3a57cd6c4b701af8fd7332372c">front</a> ()</td></tr>
<tr class="memitem:a06ed398f912a0d3ae9a61330d1fe7093" id="r_a06ed398f912a0d3ae9a61330d1fe7093"><td class="memItemLeft" align="right" valign="top">const E &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06ed398f912a0d3ae9a61330d1fe7093">front</a> () const</td></tr>
<tr class="memitem:a4355100ab9d79749ba5c024452a52bc3" id="r_a4355100ab9d79749ba5c024452a52bc3"><td class="memItemLeft" align="right" valign="top">E &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4355100ab9d79749ba5c024452a52bc3">back</a> ()</td></tr>
<tr class="memitem:a22870945d73a5593eac9ce90da316152" id="r_a22870945d73a5593eac9ce90da316152"><td class="memItemLeft" align="right" valign="top">const E &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22870945d73a5593eac9ce90da316152">back</a> () const</td></tr>
<tr class="memitem:ac1665653fe80ab19438238c718d85088" id="r_ac1665653fe80ab19438238c718d85088"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1665653fe80ab19438238c718d85088">begin</a> ()</td></tr>
<tr class="memitem:abcc5ffb7a259117db3acfa5a0fe9b500" id="r_abcc5ffb7a259117db3acfa5a0fe9b500"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcc5ffb7a259117db3acfa5a0fe9b500">begin</a> () const</td></tr>
<tr class="memitem:a61e82007f2b989a80b9c5e11b92cd131" id="r_a61e82007f2b989a80b9c5e11b92cd131"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61e82007f2b989a80b9c5e11b92cd131">end</a> ()</td></tr>
<tr class="memitem:a9c88a70fe8059053f9cbaad824d0d451" id="r_a9c88a70fe8059053f9cbaad824d0d451"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c88a70fe8059053f9cbaad824d0d451">end</a> () const</td></tr>
<tr class="memitem:ae0d40ade3d14003cb90ed272690ddfb7" id="r_ae0d40ade3d14003cb90ed272690ddfb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0d40ade3d14003cb90ed272690ddfb7">rbegin</a> ()</td></tr>
<tr class="memitem:a4e1c544f6f8f442a5a315830064f6fda" id="r_a4e1c544f6f8f442a5a315830064f6fda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e1c544f6f8f442a5a315830064f6fda">rbegin</a> () const</td></tr>
<tr class="memitem:adac54fd5fa967030178615206333e5a7" id="r_adac54fd5fa967030178615206333e5a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adac54fd5fa967030178615206333e5a7">rend</a> ()</td></tr>
<tr class="memitem:a1adab36dc43676eee2cd06cf7f61a228" id="r_a1adab36dc43676eee2cd06cf7f61a228"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1adab36dc43676eee2cd06cf7f61a228">rend</a> () const</td></tr>
<tr class="memitem:af388f486e72f2490f77206a8dc4790aa" id="r_af388f486e72f2490f77206a8dc4790aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af388f486e72f2490f77206a8dc4790aa">clear</a> ()</td></tr>
<tr class="memitem:a79fe730f0ad0c2d3fc0311dc8be2639f" id="r_a79fe730f0ad0c2d3fc0311dc8be2639f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79fe730f0ad0c2d3fc0311dc8be2639f">max_size</a> () const</td></tr>
<tr class="memitem:a1bafbcc354eccbe7b82ee1e48e26e05e" id="r_a1bafbcc354eccbe7b82ee1e48e26e05e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bafbcc354eccbe7b82ee1e48e26e05e">capacity</a> () const</td></tr>
<tr class="memitem:af6d96ae85b65a44713455b92d33ac523" id="r_af6d96ae85b65a44713455b92d33ac523"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6d96ae85b65a44713455b92d33ac523">shrink_to_fit</a> ()</td></tr>
<tr class="memitem:ab16b792368b32dc9b41f5f6efbada191" id="r_ab16b792368b32dc9b41f5f6efbada191"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab16b792368b32dc9b41f5f6efbada191">reserve</a> (int <a class="el" href="#a160da0dcb165bd9d9ad55087475bf058">size</a>)</td></tr>
<tr class="memitem:a19fe0416c0f77e5f737b6891a85dd053" id="r_a19fe0416c0f77e5f737b6891a85dd053"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19fe0416c0f77e5f737b6891a85dd053">find_first</a> (const E &amp;value) const</td></tr>
<tr class="memitem:a32b55f5a544a31eb011cfdb3a003a6a5" id="r_a32b55f5a544a31eb011cfdb3a003a6a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32b55f5a544a31eb011cfdb3a003a6a5">find_first</a> (const E &amp;value, int start_index, int end_index) const</td></tr>
<tr class="memitem:a6ee676347e89883b0d2ff06174e3d239" id="r_a6ee676347e89883b0d2ff06174e3d239"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ee676347e89883b0d2ff06174e3d239">find_first</a> (const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;predicate, int start_index, int end_index)</td></tr>
<tr class="memitem:aa2c325e435c25a994ea79a7932eabbf7" id="r_aa2c325e435c25a994ea79a7932eabbf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2c325e435c25a994ea79a7932eabbf7">find_first</a> (const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;predicate)</td></tr>
<tr class="memitem:a79fc607bd446d5827c76405ca4ef9b57" id="r_a79fc607bd446d5827c76405ca4ef9b57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79fc607bd446d5827c76405ca4ef9b57">find_first</a> (const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;predicate, int start_index, int end_index) const</td></tr>
<tr class="memitem:ad17f140d481b526b64ae8f824f68bdab" id="r_ad17f140d481b526b64ae8f824f68bdab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad17f140d481b526b64ae8f824f68bdab">find_first</a> (const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;predicate) const</td></tr>
<tr class="memitem:a2a97b71a4fa5fbfcf7c7f3913e84fec5" id="r_a2a97b71a4fa5fbfcf7c7f3913e84fec5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a97b71a4fa5fbfcf7c7f3913e84fec5">contains</a> (const E &amp;value) const</td></tr>
<tr class="memitem:a560f7f370ccd4b0b99663d05b8eead4d" id="r_a560f7f370ccd4b0b99663d05b8eead4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a560f7f370ccd4b0b99663d05b8eead4d">contains</a> (const E &amp;value, int start_index, int end_index) const</td></tr>
<tr class="memitem:a54bcb4e691d900888b4141e240783a61" id="r_a54bcb4e691d900888b4141e240783a61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54bcb4e691d900888b4141e240783a61">contains</a> (const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;predicate) const</td></tr>
<tr class="memitem:a4976b416c5eff94b084674ffa3a6b17e" id="r_a4976b416c5eff94b084674ffa3a6b17e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4976b416c5eff94b084674ffa3a6b17e">contains</a> (const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;predicate, int start_index, int end_index) const</td></tr>
<tr class="memitem:a258e8ff5de333d8536d2d163d3e890dd" id="r_a258e8ff5de333d8536d2d163d3e890dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a258e8ff5de333d8536d2d163d3e890dd">find_last</a> (const E &amp;value) const</td></tr>
<tr class="memitem:a7443ada47b3bd7a30c6b176dab842447" id="r_a7443ada47b3bd7a30c6b176dab842447"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7443ada47b3bd7a30c6b176dab842447">find_last</a> (const E &amp;value, int start_index, int end_index) const</td></tr>
<tr class="memitem:af948a955431331e8fc88827058c8762b" id="r_af948a955431331e8fc88827058c8762b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af948a955431331e8fc88827058c8762b">find_last</a> (const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;predicate, int start_index, int end_index)</td></tr>
<tr class="memitem:aad288d2b4b1d52970eaffdc4bc200cf5" id="r_aad288d2b4b1d52970eaffdc4bc200cf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad288d2b4b1d52970eaffdc4bc200cf5">find_last</a> (const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;predicate)</td></tr>
<tr class="memitem:aa823261a50c821ce798ef53e00d6f4c1" id="r_aa823261a50c821ce798ef53e00d6f4c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa823261a50c821ce798ef53e00d6f4c1">find_last</a> (const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;predicate, int start_index, int end_index) const</td></tr>
<tr class="memitem:a30ae9fbff971406c40ba45c3cbb2eca1" id="r_a30ae9fbff971406c40ba45c3cbb2eca1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30ae9fbff971406c40ba45c3cbb2eca1">find_last</a> (const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;predicate) const</td></tr>
<tr class="memitem:a9be604da91165b411a0de4e677a8e057" id="r_a9be604da91165b411a0de4e677a8e057"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9be604da91165b411a0de4e677a8e057">fill</a> (const E &amp;value)</td></tr>
<tr class="memitem:a0b3b2dd605cabfa1eef345c202fd66f8" id="r_a0b3b2dd605cabfa1eef345c202fd66f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b3b2dd605cabfa1eef345c202fd66f8">fill</a> (const E &amp;value, int start_index, int end_index)</td></tr>
<tr class="memitem:a7aba8c57e573bc7464fbede3b710f065" id="r_a7aba8c57e573bc7464fbede3b710f065"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7aba8c57e573bc7464fbede3b710f065">swap</a> (int index1, int index2)</td></tr>
<tr class="memitem:a8c17874e92863564839ef8c7a1f51133" id="r_a8c17874e92863564839ef8c7a1f51133"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c17874e92863564839ef8c7a1f51133">reverse</a> ()</td></tr>
<tr class="memitem:a7c899c416ab879141ad7880ece3b269c" id="r_a7c899c416ab879141ad7880ece3b269c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector.html">Vvector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c899c416ab879141ad7880ece3b269c">subVec</a> (int start_index, int end_index)</td></tr>
<tr class="memitem:a1df73caad3ea86020739e3b94966f64d" id="r_a1df73caad3ea86020739e3b94966f64d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1df73caad3ea86020739e3b94966f64d">Vvector</a> ()</td></tr>
<tr class="memitem:a7ded0433c63951b60e1f7e631e6266a6" id="r_a7ded0433c63951b60e1f7e631e6266a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ded0433c63951b60e1f7e631e6266a6">Vvector</a> (int <a class="el" href="#a160da0dcb165bd9d9ad55087475bf058">size</a>)</td></tr>
<tr class="memitem:a28f39db5d9b1872bfa890646ed790c25" id="r_a28f39db5d9b1872bfa890646ed790c25"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28f39db5d9b1872bfa890646ed790c25">Vvector</a> (const <a class="el" href="classshed__std_1_1_vvector.html">Vvector</a> &amp;other)</td></tr>
<tr class="memitem:a90061dac21c5fc436dd895f6bcac4f23" id="r_a90061dac21c5fc436dd895f6bcac4f23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector.html">Vvector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90061dac21c5fc436dd895f6bcac4f23">operator=</a> (const <a class="el" href="classshed__std_1_1_vvector.html">Vvector</a> &amp;other)</td></tr>
<tr class="memitem:a94aad920b5c4b71811c320ba034daf22" id="r_a94aad920b5c4b71811c320ba034daf22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94aad920b5c4b71811c320ba034daf22">operator==</a> (const <a class="el" href="classshed__std_1_1_vvector.html">Vvector</a> &amp;other) const</td></tr>
<tr class="memitem:adf4e4936727270e0268586c52e9a8cce" id="r_adf4e4936727270e0268586c52e9a8cce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf4e4936727270e0268586c52e9a8cce">operator!=</a> (const <a class="el" href="classshed__std_1_1_vvector.html">Vvector</a> &amp;other) const</td></tr>
<tr class="memitem:ab9bb04adafdc30099a2f15631412a298" id="r_ab9bb04adafdc30099a2f15631412a298"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9bb04adafdc30099a2f15631412a298">length</a> () const</td></tr>
<tr class="memitem:a160da0dcb165bd9d9ad55087475bf058" id="r_a160da0dcb165bd9d9ad55087475bf058"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a160da0dcb165bd9d9ad55087475bf058">size</a> () const</td></tr>
<tr class="memitem:a9cbfff4c78733c9d8ed344d67ba05ff3" id="r_a9cbfff4c78733c9d8ed344d67ba05ff3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cbfff4c78733c9d8ed344d67ba05ff3">empty</a> () const</td></tr>
<tr class="memitem:a472021ddaf9d30846eb9bcb6748a3a69" id="r_a472021ddaf9d30846eb9bcb6748a3a69"><td class="memItemLeft" align="right" valign="top">E &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a472021ddaf9d30846eb9bcb6748a3a69">at</a> (int index)</td></tr>
<tr class="memitem:ab3f587b849248c5cd5eb75450f8b95ea" id="r_ab3f587b849248c5cd5eb75450f8b95ea"><td class="memItemLeft" align="right" valign="top">const E &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3f587b849248c5cd5eb75450f8b95ea">at</a> (int index) const</td></tr>
<tr class="memitem:a357f3abc44bd9e9b144c0ab863a9477d" id="r_a357f3abc44bd9e9b144c0ab863a9477d"><td class="memItemLeft" align="right" valign="top">E &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a357f3abc44bd9e9b144c0ab863a9477d">operator[]</a> (int index)</td></tr>
<tr class="memitem:abf353f85d6aeac8750984de1e42913a2" id="r_abf353f85d6aeac8750984de1e42913a2"><td class="memItemLeft" align="right" valign="top">const E &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf353f85d6aeac8750984de1e42913a2">operator[]</a> (int index) const</td></tr>
<tr class="memitem:ace27eda10aa4ead8ee5165c2f6d4f274" id="r_ace27eda10aa4ead8ee5165c2f6d4f274"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace27eda10aa4ead8ee5165c2f6d4f274">push_back</a> (const E &amp;value)</td></tr>
<tr class="memitem:ad40c6b217d7b63432343d7fcbd681b5f" id="r_ad40c6b217d7b63432343d7fcbd681b5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad40c6b217d7b63432343d7fcbd681b5f">pop_back</a> ()</td></tr>
<tr class="memitem:a46cbb72fb31897c8b0dea0e53b6ee8a8" id="r_a46cbb72fb31897c8b0dea0e53b6ee8a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46cbb72fb31897c8b0dea0e53b6ee8a8">insert</a> (int index, const E &amp;value)</td></tr>
<tr class="memitem:a949e8dbdd10ffa2cf3539e8049a65f90" id="r_a949e8dbdd10ffa2cf3539e8049a65f90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a949e8dbdd10ffa2cf3539e8049a65f90">erase</a> (int index)</td></tr>
<tr class="memitem:a46262d3a57cd6c4b701af8fd7332372c" id="r_a46262d3a57cd6c4b701af8fd7332372c"><td class="memItemLeft" align="right" valign="top">E &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46262d3a57cd6c4b701af8fd7332372c">front</a> ()</td></tr>
<tr class="memitem:a06ed398f912a0d3ae9a61330d1fe7093" id="r_a06ed398f912a0d3ae9a61330d1fe7093"><td class="memItemLeft" align="right" valign="top">const E &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06ed398f912a0d3ae9a61330d1fe7093">front</a> () const</td></tr>
<tr class="memitem:a4355100ab9d79749ba5c024452a52bc3" id="r_a4355100ab9d79749ba5c024452a52bc3"><td class="memItemLeft" align="right" valign="top">E &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4355100ab9d79749ba5c024452a52bc3">back</a> ()</td></tr>
<tr class="memitem:a22870945d73a5593eac9ce90da316152" id="r_a22870945d73a5593eac9ce90da316152"><td class="memItemLeft" align="right" valign="top">const E &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22870945d73a5593eac9ce90da316152">back</a> () const</td></tr>
<tr class="memitem:a0250a8033f435ba9d36964a73f5b4a72" id="r_a0250a8033f435ba9d36964a73f5b4a72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0250a8033f435ba9d36964a73f5b4a72">begin</a> ()</td></tr>
<tr class="memitem:ae09cf97929daf79ef0b59997a3a5ab0a" id="r_ae09cf97929daf79ef0b59997a3a5ab0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae09cf97929daf79ef0b59997a3a5ab0a">begin</a> () const</td></tr>
<tr class="memitem:ac25c202c2d687622d539e2d8bfa15d53" id="r_ac25c202c2d687622d539e2d8bfa15d53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac25c202c2d687622d539e2d8bfa15d53">end</a> ()</td></tr>
<tr class="memitem:afa47a25d89200c30a63b7392a42fa6e6" id="r_afa47a25d89200c30a63b7392a42fa6e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa47a25d89200c30a63b7392a42fa6e6">end</a> () const</td></tr>
<tr class="memitem:a08c3bd7ebdcec23171c79d7f5f43370d" id="r_a08c3bd7ebdcec23171c79d7f5f43370d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08c3bd7ebdcec23171c79d7f5f43370d">rbegin</a> ()</td></tr>
<tr class="memitem:a10c80facb548f934ee24010b940e66df" id="r_a10c80facb548f934ee24010b940e66df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10c80facb548f934ee24010b940e66df">rbegin</a> () const</td></tr>
<tr class="memitem:a6f5d2f0bdab2ca31bba9168458e7dea3" id="r_a6f5d2f0bdab2ca31bba9168458e7dea3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f5d2f0bdab2ca31bba9168458e7dea3">rend</a> ()</td></tr>
<tr class="memitem:a995eae276caa504e341bea44d2522772" id="r_a995eae276caa504e341bea44d2522772"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a995eae276caa504e341bea44d2522772">rend</a> () const</td></tr>
<tr class="memitem:af388f486e72f2490f77206a8dc4790aa" id="r_af388f486e72f2490f77206a8dc4790aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af388f486e72f2490f77206a8dc4790aa">clear</a> ()</td></tr>
<tr class="memitem:a79fe730f0ad0c2d3fc0311dc8be2639f" id="r_a79fe730f0ad0c2d3fc0311dc8be2639f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79fe730f0ad0c2d3fc0311dc8be2639f">max_size</a> () const</td></tr>
<tr class="memitem:a1bafbcc354eccbe7b82ee1e48e26e05e" id="r_a1bafbcc354eccbe7b82ee1e48e26e05e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bafbcc354eccbe7b82ee1e48e26e05e">capacity</a> () const</td></tr>
<tr class="memitem:af6d96ae85b65a44713455b92d33ac523" id="r_af6d96ae85b65a44713455b92d33ac523"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6d96ae85b65a44713455b92d33ac523">shrink_to_fit</a> ()</td></tr>
<tr class="memitem:ab16b792368b32dc9b41f5f6efbada191" id="r_ab16b792368b32dc9b41f5f6efbada191"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab16b792368b32dc9b41f5f6efbada191">reserve</a> (int <a class="el" href="#a160da0dcb165bd9d9ad55087475bf058">size</a>)</td></tr>
<tr class="memitem:a19fe0416c0f77e5f737b6891a85dd053" id="r_a19fe0416c0f77e5f737b6891a85dd053"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19fe0416c0f77e5f737b6891a85dd053">find_first</a> (const E &amp;value) const</td></tr>
<tr class="memitem:a32b55f5a544a31eb011cfdb3a003a6a5" id="r_a32b55f5a544a31eb011cfdb3a003a6a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32b55f5a544a31eb011cfdb3a003a6a5">find_first</a> (const E &amp;value, int start_index, int end_index) const</td></tr>
<tr class="memitem:afa2f3826159c5310e376ff79cf49cbd7" id="r_afa2f3826159c5310e376ff79cf49cbd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa2f3826159c5310e376ff79cf49cbd7">find_first</a> (const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;predicate, int start_index, int end_index)</td></tr>
<tr class="memitem:af01fe4321eda41038f568211cd30a31d" id="r_af01fe4321eda41038f568211cd30a31d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af01fe4321eda41038f568211cd30a31d">find_first</a> (const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;predicate)</td></tr>
<tr class="memitem:ac338b0d2526a9cd349bb99b58e056b46" id="r_ac338b0d2526a9cd349bb99b58e056b46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac338b0d2526a9cd349bb99b58e056b46">find_first</a> (const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;predicate, int start_index, int end_index) const</td></tr>
<tr class="memitem:a246382406a5ddd879086bbbd02284b4e" id="r_a246382406a5ddd879086bbbd02284b4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a246382406a5ddd879086bbbd02284b4e">find_first</a> (const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;predicate) const</td></tr>
<tr class="memitem:a2a97b71a4fa5fbfcf7c7f3913e84fec5" id="r_a2a97b71a4fa5fbfcf7c7f3913e84fec5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a97b71a4fa5fbfcf7c7f3913e84fec5">contains</a> (const E &amp;value) const</td></tr>
<tr class="memitem:a560f7f370ccd4b0b99663d05b8eead4d" id="r_a560f7f370ccd4b0b99663d05b8eead4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a560f7f370ccd4b0b99663d05b8eead4d">contains</a> (const E &amp;value, int start_index, int end_index) const</td></tr>
<tr class="memitem:a54bcb4e691d900888b4141e240783a61" id="r_a54bcb4e691d900888b4141e240783a61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54bcb4e691d900888b4141e240783a61">contains</a> (const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;predicate) const</td></tr>
<tr class="memitem:a4976b416c5eff94b084674ffa3a6b17e" id="r_a4976b416c5eff94b084674ffa3a6b17e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4976b416c5eff94b084674ffa3a6b17e">contains</a> (const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;predicate, int start_index, int end_index) const</td></tr>
<tr class="memitem:a258e8ff5de333d8536d2d163d3e890dd" id="r_a258e8ff5de333d8536d2d163d3e890dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a258e8ff5de333d8536d2d163d3e890dd">find_last</a> (const E &amp;value) const</td></tr>
<tr class="memitem:a7443ada47b3bd7a30c6b176dab842447" id="r_a7443ada47b3bd7a30c6b176dab842447"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7443ada47b3bd7a30c6b176dab842447">find_last</a> (const E &amp;value, int start_index, int end_index) const</td></tr>
<tr class="memitem:a37dada5842f831834855e1bbbd88d2a1" id="r_a37dada5842f831834855e1bbbd88d2a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37dada5842f831834855e1bbbd88d2a1">find_last</a> (const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;predicate, int start_index, int end_index)</td></tr>
<tr class="memitem:a36464ab56f4cb41fc33a4df86b091ac9" id="r_a36464ab56f4cb41fc33a4df86b091ac9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36464ab56f4cb41fc33a4df86b091ac9">find_last</a> (const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;predicate)</td></tr>
<tr class="memitem:a1c19e1f5aa8fcafd17c627e951dd7aa6" id="r_a1c19e1f5aa8fcafd17c627e951dd7aa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c19e1f5aa8fcafd17c627e951dd7aa6">find_last</a> (const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;predicate, int start_index, int end_index) const</td></tr>
<tr class="memitem:a47f06ed7a0812ea482aefdde756286e1" id="r_a47f06ed7a0812ea482aefdde756286e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47f06ed7a0812ea482aefdde756286e1">find_last</a> (const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;predicate) const</td></tr>
<tr class="memitem:a9be604da91165b411a0de4e677a8e057" id="r_a9be604da91165b411a0de4e677a8e057"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9be604da91165b411a0de4e677a8e057">fill</a> (const E &amp;value)</td></tr>
<tr class="memitem:a0b3b2dd605cabfa1eef345c202fd66f8" id="r_a0b3b2dd605cabfa1eef345c202fd66f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b3b2dd605cabfa1eef345c202fd66f8">fill</a> (const E &amp;value, int start_index, int end_index)</td></tr>
<tr class="memitem:a7aba8c57e573bc7464fbede3b710f065" id="r_a7aba8c57e573bc7464fbede3b710f065"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7aba8c57e573bc7464fbede3b710f065">swap</a> (int index1, int index2)</td></tr>
<tr class="memitem:a8c17874e92863564839ef8c7a1f51133" id="r_a8c17874e92863564839ef8c7a1f51133"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c17874e92863564839ef8c7a1f51133">reverse</a> ()</td></tr>
<tr class="memitem:a503bdd48ff4e66295b053fc344e78ebe" id="r_a503bdd48ff4e66295b053fc344e78ebe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classshed__std_1_1_vvector.html">Vvector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a503bdd48ff4e66295b053fc344e78ebe">subVec</a> (int start_index, int end_index)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a20d9202bb746e1fa053672a33125459a" id="r_a20d9202bb746e1fa053672a33125459a"><td class="memItemLeft" align="right" valign="top"><a id="a20d9202bb746e1fa053672a33125459a" name="a20d9202bb746e1fa053672a33125459a"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_CAPACITY</b> = 0x40000000</td></tr>
<tr class="memitem:a3eb22397a16d937e8f5224324ffa3c7e" id="r_a3eb22397a16d937e8f5224324ffa3c7e"><td class="memItemLeft" align="right" valign="top"><a id="a3eb22397a16d937e8f5224324ffa3c7e" name="a3eb22397a16d937e8f5224324ffa3c7e"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_SIZE</b> = 0x40000000</td></tr>
</table>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1df73caad3ea86020739e3b94966f64d" name="a1df73caad3ea86020739e3b94966f64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df73caad3ea86020739e3b94966f64d">&#9670;&#160;</a></span>Vvector() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数，默认容量为1024，大小为0 </p>

</div>
</div>
<a id="a7ded0433c63951b60e1f7e631e6266a6" name="a7ded0433c63951b60e1f7e631e6266a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ded0433c63951b60e1f7e631e6266a6">&#9670;&#160;</a></span>Vvector() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数，指定初始大小，容量为适合该大小的2的幂次 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>初始大小 </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classshed__std_1_1_eexception.html">Eexception</a></td><td>当size为负数或超过MAX_CAPACITY时抛出异常 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28f39db5d9b1872bfa890646ed790c25" name="a28f39db5d9b1872bfa890646ed790c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f39db5d9b1872bfa890646ed790c25">&#9670;&#160;</a></span>Vvector() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_vvector.html">Vvector</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>拷贝构造函数，实现深拷贝 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>另一个Vvector对象 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1df73caad3ea86020739e3b94966f64d" name="a1df73caad3ea86020739e3b94966f64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df73caad3ea86020739e3b94966f64d">&#9670;&#160;</a></span>Vvector() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>构造函数，默认容量为1024,大小为0 </p>

</div>
</div>
<a id="a7ded0433c63951b60e1f7e631e6266a6" name="a7ded0433c63951b60e1f7e631e6266a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ded0433c63951b60e1f7e631e6266a6">&#9670;&#160;</a></span>Vvector() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>构造函数，指定size，初始容量由内部确定，是2的幂次 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>大小 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28f39db5d9b1872bfa890646ed790c25" name="a28f39db5d9b1872bfa890646ed790c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f39db5d9b1872bfa890646ed790c25">&#9670;&#160;</a></span>Vvector() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_vvector.html">Vvector</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>拷贝构造函数,实现深拷贝 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>另外一个需要拷贝的Vvector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a472021ddaf9d30846eb9bcb6748a3a69" name="a472021ddaf9d30846eb9bcb6748a3a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472021ddaf9d30846eb9bcb6748a3a69">&#9670;&#160;</a></span>at() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">E &amp; <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::at </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取指定索引的元素引用（带越界检查） </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>元素索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>元素的引用 </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classshed__std_1_1_eexception.html">Eexception</a></td><td>当index&lt;0或index&gt;=_size时抛出异常 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a472021ddaf9d30846eb9bcb6748a3a69" name="a472021ddaf9d30846eb9bcb6748a3a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472021ddaf9d30846eb9bcb6748a3a69">&#9670;&#160;</a></span>at() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">E &amp; <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::at </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回指定位置的引用，提供位置检查 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>下标 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3f587b849248c5cd5eb75450f8b95ea" name="ab3f587b849248c5cd5eb75450f8b95ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f587b849248c5cd5eb75450f8b95ea">&#9670;&#160;</a></span>at() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const E &amp; <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::at </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取指定索引的元素常量引用（带越界检查） </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>元素索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>元素的常量引用 </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classshed__std_1_1_eexception.html">Eexception</a></td><td>当index&lt;0或index&gt;=_size时抛出异常 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3f587b849248c5cd5eb75450f8b95ea" name="ab3f587b849248c5cd5eb75450f8b95ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f587b849248c5cd5eb75450f8b95ea">&#9670;&#160;</a></span>at() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const E &amp; <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::at </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回指定位置的常量引用，提供位置检查，供常量使用 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>下标 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4355100ab9d79749ba5c024452a52bc3" name="a4355100ab9d79749ba5c024452a52bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4355100ab9d79749ba5c024452a52bc3">&#9670;&#160;</a></span>back() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">E &amp; <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取最后一个元素的引用 </p><dl class="section return"><dt>Returns</dt><dd>最后一个元素的引用 </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classshed__std_1_1_eexception.html">Eexception</a></td><td>当Vvector为空时抛出异常 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4355100ab9d79749ba5c024452a52bc3" name="a4355100ab9d79749ba5c024452a52bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4355100ab9d79749ba5c024452a52bc3">&#9670;&#160;</a></span>back() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">E &amp; <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回最后一个元素的引用 </p><dl class="section return"><dt>Returns</dt><dd>引用 </dd></dl>

</div>
</div>
<a id="a22870945d73a5593eac9ce90da316152" name="a22870945d73a5593eac9ce90da316152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22870945d73a5593eac9ce90da316152">&#9670;&#160;</a></span>back() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const E &amp; <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取最后一个元素的常量引用 </p><dl class="section return"><dt>Returns</dt><dd>最后一个元素的常量引用 </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classshed__std_1_1_eexception.html">Eexception</a></td><td>当Vvector为空时抛出异常 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22870945d73a5593eac9ce90da316152" name="a22870945d73a5593eac9ce90da316152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22870945d73a5593eac9ce90da316152">&#9670;&#160;</a></span>back() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const E &amp; <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回最后一个元素的常量引用，供常量使用 </p><dl class="section return"><dt>Returns</dt><dd>引用 </dd></dl>

</div>
</div>
<a id="ac1665653fe80ab19438238c718d85088" name="ac1665653fe80ab19438238c718d85088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1665653fe80ab19438238c718d85088">&#9670;&#160;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector_iterator <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取指向起始元素的迭代器 </p><dl class="section return"><dt>Returns</dt><dd>起始迭代器 </dd></dl>

</div>
</div>
<a id="a0250a8033f435ba9d36964a73f5b4a72" name="a0250a8033f435ba9d36964a73f5b4a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0250a8033f435ba9d36964a73f5b4a72">&#9670;&#160;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a> <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回指向开始的迭代器 </p><dl class="section return"><dt>Returns</dt><dd>指向开始的迭代器 </dd></dl>

</div>
</div>
<a id="abcc5ffb7a259117db3acfa5a0fe9b500" name="abcc5ffb7a259117db3acfa5a0fe9b500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc5ffb7a259117db3acfa5a0fe9b500">&#9670;&#160;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector_const_iterator <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取指向起始元素的常量迭代器 </p><dl class="section return"><dt>Returns</dt><dd>起始常量迭代器 </dd></dl>

</div>
</div>
<a id="ae09cf97929daf79ef0b59997a3a5ab0a" name="ae09cf97929daf79ef0b59997a3a5ab0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09cf97929daf79ef0b59997a3a5ab0a">&#9670;&#160;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a> <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回指向开始的常量迭代器 </p><dl class="section return"><dt>Returns</dt><dd>指向开始的常量迭代器 </dd></dl>

</div>
</div>
<a id="a1bafbcc354eccbe7b82ee1e48e26e05e" name="a1bafbcc354eccbe7b82ee1e48e26e05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bafbcc354eccbe7b82ee1e48e26e05e">&#9670;&#160;</a></span>capacity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取当前容量 </p><dl class="section return"><dt>Returns</dt><dd>容量大小 </dd></dl>

</div>
</div>
<a id="a1bafbcc354eccbe7b82ee1e48e26e05e" name="a1bafbcc354eccbe7b82ee1e48e26e05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bafbcc354eccbe7b82ee1e48e26e05e">&#9670;&#160;</a></span>capacity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回容量大小 </p><dl class="section return"><dt>Returns</dt><dd>容量大小 </dd></dl>

</div>
</div>
<a id="af388f486e72f2490f77206a8dc4790aa" name="af388f486e72f2490f77206a8dc4790aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af388f486e72f2490f77206a8dc4790aa">&#9670;&#160;</a></span>clear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>清空Vvector（仅重置大小为0，不释放容量，不调用元素析构函数） </p>

</div>
</div>
<a id="af388f486e72f2490f77206a8dc4790aa" name="af388f486e72f2490f77206a8dc4790aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af388f486e72f2490f77206a8dc4790aa">&#9670;&#160;</a></span>clear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>注意:本方法不会调用构析函数，不会释放容量，只会重置大小 </p>

</div>
</div>
<a id="a2a97b71a4fa5fbfcf7c7f3913e84fec5" name="a2a97b71a4fa5fbfcf7c7f3913e84fec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a97b71a4fa5fbfcf7c7f3913e84fec5">&#9670;&#160;</a></span>contains() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>判断Vvector是否包含指定值 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>目标值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含则返回true，否则返回false </dd></dl>

</div>
</div>
<a id="a2a97b71a4fa5fbfcf7c7f3913e84fec5" name="a2a97b71a4fa5fbfcf7c7f3913e84fec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a97b71a4fa5fbfcf7c7f3913e84fec5">&#9670;&#160;</a></span>contains() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>当前容器是否包含某个值 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>需要查找的值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>是否包含，包含时返回真 </dd></dl>

</div>
</div>
<a id="a560f7f370ccd4b0b99663d05b8eead4d" name="a560f7f370ccd4b0b99663d05b8eead4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560f7f370ccd4b0b99663d05b8eead4d">&#9670;&#160;</a></span>contains() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>判断[start_index, end_index)范围内是否包含指定值 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>目标值 </td></tr>
    <tr><td class="paramname">start_index</td><td>起始索引（包含） </td></tr>
    <tr><td class="paramname">end_index</td><td>结束索引（不包含） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含则返回true，否则返回false </dd></dl>

</div>
</div>
<a id="a560f7f370ccd4b0b99663d05b8eead4d" name="a560f7f370ccd4b0b99663d05b8eead4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560f7f370ccd4b0b99663d05b8eead4d">&#9670;&#160;</a></span>contains() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>当前容器在[start_index,end_index)的范围上是否包含某个值 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>需要查找的值 </td></tr>
    <tr><td class="paramname">start_index</td><td>开始的下标 </td></tr>
    <tr><td class="paramname">end_index</td><td>结束下标 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>是否包含，包含时返回真 </dd></dl>

</div>
</div>
<a id="a54bcb4e691d900888b4141e240783a61" name="a54bcb4e691d900888b4141e240783a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bcb4e691d900888b4141e240783a61">&#9670;&#160;</a></span>contains() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>判断Vvector是否包含满足谓词条件的元素 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>谓词函数（参数为const E&amp;，返回bool） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含则返回true，否则返回false </dd></dl>

</div>
</div>
<a id="a54bcb4e691d900888b4141e240783a61" name="a54bcb4e691d900888b4141e240783a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bcb4e691d900888b4141e240783a61">&#9670;&#160;</a></span>contains() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>当前容器是否包含符合某个条件的值 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>谓词，当代入查找值时，返回真或假 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>是否包含，包含时返回真 </dd></dl>

</div>
</div>
<a id="a4976b416c5eff94b084674ffa3a6b17e" name="a4976b416c5eff94b084674ffa3a6b17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4976b416c5eff94b084674ffa3a6b17e">&#9670;&#160;</a></span>contains() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>判断[start_index, end_index)范围内是否包含满足谓词条件的元素 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>谓词函数（参数为const E&amp;，返回bool） </td></tr>
    <tr><td class="paramname">start_index</td><td>起始索引（包含） </td></tr>
    <tr><td class="paramname">end_index</td><td>结束索引（不包含） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含则返回true，否则返回false </dd></dl>

</div>
</div>
<a id="a4976b416c5eff94b084674ffa3a6b17e" name="a4976b416c5eff94b084674ffa3a6b17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4976b416c5eff94b084674ffa3a6b17e">&#9670;&#160;</a></span>contains() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>当前容器在[start_index,end_index)上是否包含符合某个条件的值 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>谓词，当代入查找值时，返回真或假 </td></tr>
    <tr><td class="paramname">start_index</td><td>开始的下标 </td></tr>
    <tr><td class="paramname">end_index</td><td>结束下标 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>是否包含，包含时返回真 </dd></dl>

</div>
</div>
<a id="a9cbfff4c78733c9d8ed344d67ba05ff3" name="a9cbfff4c78733c9d8ed344d67ba05ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbfff4c78733c9d8ed344d67ba05ff3">&#9670;&#160;</a></span>empty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>判断Vvector是否为空 </p><dl class="section return"><dt>Returns</dt><dd>若大小为0则返回true，否则返回false </dd></dl>

</div>
</div>
<a id="a9cbfff4c78733c9d8ed344d67ba05ff3" name="a9cbfff4c78733c9d8ed344d67ba05ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbfff4c78733c9d8ed344d67ba05ff3">&#9670;&#160;</a></span>empty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回容器是否为空，根据size判断 </p>

</div>
</div>
<a id="a61e82007f2b989a80b9c5e11b92cd131" name="a61e82007f2b989a80b9c5e11b92cd131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e82007f2b989a80b9c5e11b92cd131">&#9670;&#160;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector_iterator <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取指向末尾（最后一个元素后一位）的迭代器 </p><dl class="section return"><dt>Returns</dt><dd>末尾迭代器 </dd></dl>

</div>
</div>
<a id="ac25c202c2d687622d539e2d8bfa15d53" name="ac25c202c2d687622d539e2d8bfa15d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25c202c2d687622d539e2d8bfa15d53">&#9670;&#160;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a> <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回指向结尾的迭代器 </p><dl class="section return"><dt>Returns</dt><dd>指向结尾的迭代器 </dd></dl>

</div>
</div>
<a id="a9c88a70fe8059053f9cbaad824d0d451" name="a9c88a70fe8059053f9cbaad824d0d451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c88a70fe8059053f9cbaad824d0d451">&#9670;&#160;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector_const_iterator <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取指向末尾（最后一个元素后一位）的常量迭代器 </p><dl class="section return"><dt>Returns</dt><dd>末尾常量迭代器 </dd></dl>

</div>
</div>
<a id="afa47a25d89200c30a63b7392a42fa6e6" name="afa47a25d89200c30a63b7392a42fa6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa47a25d89200c30a63b7392a42fa6e6">&#9670;&#160;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a> <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回指向结尾的常量迭代器 </p><dl class="section return"><dt>Returns</dt><dd>指向结尾的常量迭代器 </dd></dl>

</div>
</div>
<a id="a949e8dbdd10ffa2cf3539e8049a65f90" name="a949e8dbdd10ffa2cf3539e8049a65f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949e8dbdd10ffa2cf3539e8049a65f90">&#9670;&#160;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>删除指定索引位置的元素 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>要删除的元素索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classshed__std_1_1_eexception.html">Eexception</a></td><td>当index&lt;0或index&gt;=_size时抛出异常 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a949e8dbdd10ffa2cf3539e8049a65f90" name="a949e8dbdd10ffa2cf3539e8049a65f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949e8dbdd10ffa2cf3539e8049a65f90">&#9670;&#160;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在index位置删除元素，index和index之后的数字都将前移 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>下标 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9be604da91165b411a0de4e677a8e057" name="a9be604da91165b411a0de4e677a8e057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be604da91165b411a0de4e677a8e057">&#9670;&#160;</a></span>fill() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用指定值填充整个Vvector </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>填充值 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9be604da91165b411a0de4e677a8e057" name="a9be604da91165b411a0de4e677a8e057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be604da91165b411a0de4e677a8e057">&#9670;&#160;</a></span>fill() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将整个容器填充指定值 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>值 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b3b2dd605cabfa1eef345c202fd66f8" name="a0b3b2dd605cabfa1eef345c202fd66f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3b2dd605cabfa1eef345c202fd66f8">&#9670;&#160;</a></span>fill() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在[start_index, end_index)范围内用指定值填充 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>填充值 </td></tr>
    <tr><td class="paramname">start_index</td><td>起始索引（包含） </td></tr>
    <tr><td class="paramname">end_index</td><td>结束索引（不包含） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>若范围不合法，则不执行填充操作 </dd></dl>

</div>
</div>
<a id="a0b3b2dd605cabfa1eef345c202fd66f8" name="a0b3b2dd605cabfa1eef345c202fd66f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3b2dd605cabfa1eef345c202fd66f8">&#9670;&#160;</a></span>fill() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在[start_index,end_index)填充指定值,在不合法的范围内，填充将不会执行 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>值 </td></tr>
    <tr><td class="paramname">start_index</td><td>开始的下标 </td></tr>
    <tr><td class="paramname">end_index</td><td>结束的下标 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19fe0416c0f77e5f737b6891a85dd053" name="a19fe0416c0f77e5f737b6891a85dd053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19fe0416c0f77e5f737b6891a85dd053">&#9670;&#160;</a></span>find_first() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_first </td>
          <td>(</td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>查找第一个等于指定值的元素下标 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>目标值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>第一个匹配元素的下标，未找到则返回-1 </dd></dl>

</div>
</div>
<a id="a19fe0416c0f77e5f737b6891a85dd053" name="a19fe0416c0f77e5f737b6891a85dd053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19fe0416c0f77e5f737b6891a85dd053">&#9670;&#160;</a></span>find_first() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_first </td>
          <td>(</td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>找到第一个符合条件的元素的下标，找不到时返回-1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>需要查找的值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>第一个符合条件的元素的下标 </dd></dl>

</div>
</div>
<a id="a32b55f5a544a31eb011cfdb3a003a6a5" name="a32b55f5a544a31eb011cfdb3a003a6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b55f5a544a31eb011cfdb3a003a6a5">&#9670;&#160;</a></span>find_first() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_first </td>
          <td>(</td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在[start_index, end_index)范围内查找第一个等于指定值的元素下标 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>目标值 </td></tr>
    <tr><td class="paramname">start_index</td><td>起始索引（包含） </td></tr>
    <tr><td class="paramname">end_index</td><td>结束索引（不包含） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>第一个匹配元素的下标，范围不合法或未找到则返回-1 </dd></dl>

</div>
</div>
<a id="a32b55f5a544a31eb011cfdb3a003a6a5" name="a32b55f5a544a31eb011cfdb3a003a6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b55f5a544a31eb011cfdb3a003a6a5">&#9670;&#160;</a></span>find_first() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_first </td>
          <td>(</td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>找到第一个符合条件的元素的下标，[start_index,end_index)，找不到时，返回-1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>需要查找的值 </td></tr>
    <tr><td class="paramname">start_index</td><td>开始的下标（含） </td></tr>
    <tr><td class="paramname">end_index</td><td>结束的下标（不含） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>第一个符合条件的元素的下标 </dd></dl>

</div>
</div>
<a id="aa2c325e435c25a994ea79a7932eabbf7" name="aa2c325e435c25a994ea79a7932eabbf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c325e435c25a994ea79a7932eabbf7">&#9670;&#160;</a></span>find_first() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector_iterator <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在整个Vvector中查找第一个满足谓词条件的元素 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>谓词函数（参数为const E&amp;，返回bool） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>指向第一个匹配元素的迭代器，未找到则返回end() </dd></dl>

</div>
</div>
<a id="af01fe4321eda41038f568211cd30a31d" name="af01fe4321eda41038f568211cd30a31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01fe4321eda41038f568211cd30a31d">&#9670;&#160;</a></span>find_first() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a> <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>找到第一个符合条件的元素，返回迭代器,[start_index,end_index)，找不到时返回end()或end_index的迭代器 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>谓词，或者你的判断函数，要求返回值为bool，参数类型为const E&amp;，每次迭代将传入当前元素的值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>普通迭代器 </dd></dl>

</div>
</div>
<a id="ad17f140d481b526b64ae8f824f68bdab" name="ad17f140d481b526b64ae8f824f68bdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17f140d481b526b64ae8f824f68bdab">&#9670;&#160;</a></span>find_first() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector_const_iterator <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在整个Vvector中查找第一个满足谓词条件的元素（常量版本） </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>谓词函数（参数为const E&amp;，返回bool） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>指向第一个匹配元素的常量迭代器，未找到则返回end() </dd></dl>

</div>
</div>
<a id="a246382406a5ddd879086bbbd02284b4e" name="a246382406a5ddd879086bbbd02284b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246382406a5ddd879086bbbd02284b4e">&#9670;&#160;</a></span>find_first() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a> <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>找到第一个符合条件的元素，返回迭代器,[start_index,end_index)，找不到时返回end()或end_index的迭代器，供常量使用 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>谓词，或者你的判断函数，要求返回值为bool，参数类型为const E&amp;，每次迭代将传入当前元素的值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>常量迭代器 </dd></dl>

</div>
</div>
<a id="a6ee676347e89883b0d2ff06174e3d239" name="a6ee676347e89883b0d2ff06174e3d239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee676347e89883b0d2ff06174e3d239">&#9670;&#160;</a></span>find_first() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector_iterator <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在[start_index, end_index)范围内查找第一个满足谓词条件的元素 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>谓词函数（参数为const E&amp;，返回bool） </td></tr>
    <tr><td class="paramname">start_index</td><td>起始索引（包含） </td></tr>
    <tr><td class="paramname">end_index</td><td>结束索引（不包含） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>指向第一个匹配元素的迭代器，范围不合法或未找到则返回end() </dd></dl>

</div>
</div>
<a id="afa2f3826159c5310e376ff79cf49cbd7" name="afa2f3826159c5310e376ff79cf49cbd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2f3826159c5310e376ff79cf49cbd7">&#9670;&#160;</a></span>find_first() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a> <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>找到第一个符合条件的元素，返回迭代器,[start_index,end_index)，找不到时返回end()或end_index的迭代器 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>谓词，或者你的判断函数，要求返回值为bool，参数类型为const E&amp;,每次迭代将传入当前元素的值 </td></tr>
    <tr><td class="paramname">start_index</td><td>开始位置的下标(含) </td></tr>
    <tr><td class="paramname">end_index</td><td>结束位置的下标（不含） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>普通迭代器 </dd></dl>

</div>
</div>
<a id="a79fc607bd446d5827c76405ca4ef9b57" name="a79fc607bd446d5827c76405ca4ef9b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fc607bd446d5827c76405ca4ef9b57">&#9670;&#160;</a></span>find_first() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector_const_iterator <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在[start_index, end_index)范围内查找第一个满足谓词条件的元素（常量版本） </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>谓词函数（参数为const E&amp;，返回bool） </td></tr>
    <tr><td class="paramname">start_index</td><td>起始索引（包含） </td></tr>
    <tr><td class="paramname">end_index</td><td>结束索引（不包含） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>指向第一个匹配元素的常量迭代器，范围不合法或未找到则返回end() </dd></dl>

</div>
</div>
<a id="ac338b0d2526a9cd349bb99b58e056b46" name="ac338b0d2526a9cd349bb99b58e056b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac338b0d2526a9cd349bb99b58e056b46">&#9670;&#160;</a></span>find_first() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a> <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>找到第一个符合条件的元素，返回迭代器,[start_index,end_index)，找不到时返回end()或end_index的迭代器，供常量使用 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>谓词，或者你的判断函数，要求返回值为bool，参数类型为const E&amp;，每次迭代将传入当前元素的值 </td></tr>
    <tr><td class="paramname">start_index</td><td>开始位置的下标(含) </td></tr>
    <tr><td class="paramname">end_index</td><td>结束位置的下标（不含） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>常量迭代器 </dd></dl>

</div>
</div>
<a id="a258e8ff5de333d8536d2d163d3e890dd" name="a258e8ff5de333d8536d2d163d3e890dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258e8ff5de333d8536d2d163d3e890dd">&#9670;&#160;</a></span>find_last() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>查找最后一个等于指定值的元素下标 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>目标值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>最后一个匹配元素的下标，未找到则返回-1 </dd></dl>

</div>
</div>
<a id="a258e8ff5de333d8536d2d163d3e890dd" name="a258e8ff5de333d8536d2d163d3e890dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258e8ff5de333d8536d2d163d3e890dd">&#9670;&#160;</a></span>find_last() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>找到最后一个符合条件的元素的下标，找不到时返回-1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>需要查找的值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>最后一个符合条件的元素的下标 </dd></dl>

</div>
</div>
<a id="a7443ada47b3bd7a30c6b176dab842447" name="a7443ada47b3bd7a30c6b176dab842447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7443ada47b3bd7a30c6b176dab842447">&#9670;&#160;</a></span>find_last() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在[start_index, end_index)范围内查找最后一个等于指定值的元素下标 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>目标值 </td></tr>
    <tr><td class="paramname">start_index</td><td>起始索引（包含） </td></tr>
    <tr><td class="paramname">end_index</td><td>结束索引（不包含） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>最后一个匹配元素的下标，范围不合法或未找到则返回-1 </dd></dl>

</div>
</div>
<a id="a7443ada47b3bd7a30c6b176dab842447" name="a7443ada47b3bd7a30c6b176dab842447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7443ada47b3bd7a30c6b176dab842447">&#9670;&#160;</a></span>find_last() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>找到在[start_index,end_index)上最后一个符合条件的元素的下标，找不到时返回-1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>需要查找的值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>最后一个符合条件的元素的下标 </dd></dl>

</div>
</div>
<a id="aad288d2b4b1d52970eaffdc4bc200cf5" name="aad288d2b4b1d52970eaffdc4bc200cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad288d2b4b1d52970eaffdc4bc200cf5">&#9670;&#160;</a></span>find_last() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector_iterator <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在整个Vvector中查找最后一个满足谓词条件的元素 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>谓词函数（参数为const E&amp;，返回bool） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>指向最后一个匹配元素的迭代器，未找到则返回end() </dd></dl>

</div>
</div>
<a id="a36464ab56f4cb41fc33a4df86b091ac9" name="a36464ab56f4cb41fc33a4df86b091ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36464ab56f4cb41fc33a4df86b091ac9">&#9670;&#160;</a></span>find_last() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a> <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>找到最后一个符合条件的元素，返回其迭代器，不合法和没有找到时返回end() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>谓词/函数，返回bool，参数为const E&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>元素的普通迭代器 </dd></dl>

</div>
</div>
<a id="a30ae9fbff971406c40ba45c3cbb2eca1" name="a30ae9fbff971406c40ba45c3cbb2eca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ae9fbff971406c40ba45c3cbb2eca1">&#9670;&#160;</a></span>find_last() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector_const_iterator <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在整个Vvector中查找最后一个满足谓词条件的元素（常量版本） </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>谓词函数（参数为const E&amp;，返回bool） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>指向最后一个匹配元素的常量迭代器，未找到则返回end() </dd></dl>

</div>
</div>
<a id="a47f06ed7a0812ea482aefdde756286e1" name="a47f06ed7a0812ea482aefdde756286e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f06ed7a0812ea482aefdde756286e1">&#9670;&#160;</a></span>find_last() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a> <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>找到最后一个符合条件的元素，返回其迭代器，不合法和没有找到时返回end()，供常量使用 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>谓词/函数，返回bool，参数为const E&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>元素的常量迭代器 </dd></dl>

</div>
</div>
<a id="af948a955431331e8fc88827058c8762b" name="af948a955431331e8fc88827058c8762b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af948a955431331e8fc88827058c8762b">&#9670;&#160;</a></span>find_last() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector_iterator <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在[start_index, end_index)范围内查找最后一个满足谓词条件的元素 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>谓词函数（参数为const E&amp;，返回bool） </td></tr>
    <tr><td class="paramname">start_index</td><td>起始索引（包含） </td></tr>
    <tr><td class="paramname">end_index</td><td>结束索引（不包含） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>指向最后一个匹配元素的迭代器，范围不合法则返回end()，未找到则返回指向end_index的迭代器 </dd></dl>

</div>
</div>
<a id="a37dada5842f831834855e1bbbd88d2a1" name="a37dada5842f831834855e1bbbd88d2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37dada5842f831834855e1bbbd88d2a1">&#9670;&#160;</a></span>find_last() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a> <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>找到在[start_index,end_index)最后一个符合条件的元素，返回其迭代器，不合法时返回end()，未找到返回end_index的迭代器 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>谓词/函数，返回bool，参数为const E&amp; </td></tr>
    <tr><td class="paramname">start_index</td><td>区间开始（含) </td></tr>
    <tr><td class="paramname">end_index</td><td>区间结束（不含） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>元素的普通迭代器 </dd></dl>

</div>
</div>
<a id="aa823261a50c821ce798ef53e00d6f4c1" name="aa823261a50c821ce798ef53e00d6f4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa823261a50c821ce798ef53e00d6f4c1">&#9670;&#160;</a></span>find_last() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector_const_iterator <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在[start_index, end_index)范围内查找最后一个满足谓词条件的元素（常量版本） </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>谓词函数（参数为const E&amp;，返回bool） </td></tr>
    <tr><td class="paramname">start_index</td><td>起始索引（包含） </td></tr>
    <tr><td class="paramname">end_index</td><td>结束索引（不包含） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>指向最后一个匹配元素的常量迭代器，范围不合法则返回end()，未找到则返回指向end_index的迭代器 </dd></dl>

</div>
</div>
<a id="a1c19e1f5aa8fcafd17c627e951dd7aa6" name="a1c19e1f5aa8fcafd17c627e951dd7aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c19e1f5aa8fcafd17c627e951dd7aa6">&#9670;&#160;</a></span>find_last() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a> <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::find_last </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_ffunction.html">Ffunction</a>&lt; bool, const E &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>找到在[start_index,end_index)最后一个符合条件的元素，返回其常量迭代器，不合法时返回end()，未找到返回end_index的迭代器，供常量使用 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>谓词/函数，返回bool，参数为const E&amp; </td></tr>
    <tr><td class="paramname">start_index</td><td>区间开始（含) </td></tr>
    <tr><td class="paramname">end_index</td><td>区间结束（不含） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>元素的常量迭代器 </dd></dl>

</div>
</div>
<a id="a46262d3a57cd6c4b701af8fd7332372c" name="a46262d3a57cd6c4b701af8fd7332372c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46262d3a57cd6c4b701af8fd7332372c">&#9670;&#160;</a></span>front() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">E &amp; <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取第一个元素的引用 </p><dl class="section return"><dt>Returns</dt><dd>第一个元素的引用 </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classshed__std_1_1_eexception.html">Eexception</a></td><td>当Vvector为空时抛出异常 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46262d3a57cd6c4b701af8fd7332372c" name="a46262d3a57cd6c4b701af8fd7332372c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46262d3a57cd6c4b701af8fd7332372c">&#9670;&#160;</a></span>front() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">E &amp; <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回第一个元素的引用 </p><dl class="section return"><dt>Returns</dt><dd>引用 </dd></dl>

</div>
</div>
<a id="a06ed398f912a0d3ae9a61330d1fe7093" name="a06ed398f912a0d3ae9a61330d1fe7093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ed398f912a0d3ae9a61330d1fe7093">&#9670;&#160;</a></span>front() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const E &amp; <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取第一个元素的常量引用 </p><dl class="section return"><dt>Returns</dt><dd>第一个元素的常量引用 </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classshed__std_1_1_eexception.html">Eexception</a></td><td>当Vvector为空时抛出异常 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06ed398f912a0d3ae9a61330d1fe7093" name="a06ed398f912a0d3ae9a61330d1fe7093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ed398f912a0d3ae9a61330d1fe7093">&#9670;&#160;</a></span>front() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const E &amp; <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::front </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回第一个元素的常量引用，提供给常量使用 </p><dl class="section return"><dt>Returns</dt><dd>引用 </dd></dl>

</div>
</div>
<a id="a46cbb72fb31897c8b0dea0e53b6ee8a8" name="a46cbb72fb31897c8b0dea0e53b6ee8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46cbb72fb31897c8b0dea0e53b6ee8a8">&#9670;&#160;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在指定索引位置插入元素 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>插入位置索引 </td></tr>
    <tr><td class="paramname">value</td><td>要插入的元素值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classshed__std_1_1_eexception.html">Eexception</a></td><td>当index&lt;0或index&gt;_size时抛出异常；Vvector已达MAX_SIZE时抛出异常；扩容失败时也可能抛出异常 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46cbb72fb31897c8b0dea0e53b6ee8a8" name="a46cbb72fb31897c8b0dea0e53b6ee8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46cbb72fb31897c8b0dea0e53b6ee8a8">&#9670;&#160;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在index位置插入值，index及以后的值都会向后移动一个单位 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>下标 </td></tr>
    <tr><td class="paramname">value</td><td>值 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9bb04adafdc30099a2f15631412a298" name="ab9bb04adafdc30099a2f15631412a298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bb04adafdc30099a2f15631412a298">&#9670;&#160;</a></span>length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::length </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取当前Vvector的大小 </p><dl class="section return"><dt>Returns</dt><dd>元素个数 </dd></dl>

</div>
</div>
<a id="ab9bb04adafdc30099a2f15631412a298" name="ab9bb04adafdc30099a2f15631412a298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bb04adafdc30099a2f15631412a298">&#9670;&#160;</a></span>length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::length </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回大小 </p><dl class="section return"><dt>Returns</dt><dd>Vvector的大小 </dd></dl>

</div>
</div>
<a id="a79fe730f0ad0c2d3fc0311dc8be2639f" name="a79fe730f0ad0c2d3fc0311dc8be2639f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fe730f0ad0c2d3fc0311dc8be2639f">&#9670;&#160;</a></span>max_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取Vvector的最大容量限制 </p><dl class="section return"><dt>Returns</dt><dd>最大元素个数 </dd></dl>

</div>
</div>
<a id="a79fe730f0ad0c2d3fc0311dc8be2639f" name="a79fe730f0ad0c2d3fc0311dc8be2639f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fe730f0ad0c2d3fc0311dc8be2639f">&#9670;&#160;</a></span>max_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回最大元素个数 </p><dl class="section return"><dt>Returns</dt><dd>最大元素个数 </dd></dl>

</div>
</div>
<a id="adf4e4936727270e0268586c52e9a8cce" name="adf4e4936727270e0268586c52e9a8cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4e4936727270e0268586c52e9a8cce">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_vvector.html">Vvector</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>不等比较运算符 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>另一个Vvector对象 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>两个对象是否不相等 </dd></dl>

</div>
</div>
<a id="adf4e4936727270e0268586c52e9a8cce" name="adf4e4936727270e0268586c52e9a8cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4e4936727270e0268586c52e9a8cce">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_vvector.html">Vvector</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>判断两个Vvector是否不等，依靠==实现 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>另外一个Vvector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>两个Vvector是否不等 </dd></dl>

</div>
</div>
<a id="ae0a64b9bb2e5f7b90d31731068bd5f69" name="ae0a64b9bb2e5f7b90d31731068bd5f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a64b9bb2e5f7b90d31731068bd5f69">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt; &amp; <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_vvector.html">Vvector</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>赋值运算符，实现深拷贝 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>另一个Vvector对象 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>当前对象的引用 </dd></dl>

</div>
</div>
<a id="a90061dac21c5fc436dd895f6bcac4f23" name="a90061dac21c5fc436dd895f6bcac4f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90061dac21c5fc436dd895f6bcac4f23">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">Vvector</a> &amp; <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_vvector.html">Vvector</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>等号拷贝赋值，支持深拷贝 </p>

</div>
</div>
<a id="a94aad920b5c4b71811c320ba034daf22" name="a94aad920b5c4b71811c320ba034daf22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94aad920b5c4b71811c320ba034daf22">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_vvector.html">Vvector</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>相等比较运算符 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>另一个Vvector对象 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>两个对象是否相等（大小相同且元素均相同） </dd></dl>

</div>
</div>
<a id="a94aad920b5c4b71811c320ba034daf22" name="a94aad920b5c4b71811c320ba034daf22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94aad920b5c4b71811c320ba034daf22">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classshed__std_1_1_vvector.html">Vvector</a>&lt; E &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>判断两个Vvector是否相等 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>另外一个Vvector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>两个Vvector是否相等 </dd></dl>

</div>
</div>
<a id="a357f3abc44bd9e9b144c0ab863a9477d" name="a357f3abc44bd9e9b144c0ab863a9477d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357f3abc44bd9e9b144c0ab863a9477d">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">E &amp; <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>下标运算符，通过索引访问元素（调用at()实现） </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>元素索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>元素的引用 </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classshed__std_1_1_eexception.html">Eexception</a></td><td>当index&lt;0或index&gt;=_size时抛出异常 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a357f3abc44bd9e9b144c0ab863a9477d" name="a357f3abc44bd9e9b144c0ab863a9477d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357f3abc44bd9e9b144c0ab863a9477d">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">E &amp; <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回指定位置的引用，提供位置检查，实际由at方法实现 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>位置 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf353f85d6aeac8750984de1e42913a2" name="abf353f85d6aeac8750984de1e42913a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf353f85d6aeac8750984de1e42913a2">&#9670;&#160;</a></span>operator[]() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const E &amp; <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>常量下标运算符，通过索引访问元素（调用at()实现） </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>元素索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>元素的常量引用 </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classshed__std_1_1_eexception.html">Eexception</a></td><td>当index&lt;0或index&gt;=_size时抛出异常 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf353f85d6aeac8750984de1e42913a2" name="abf353f85d6aeac8750984de1e42913a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf353f85d6aeac8750984de1e42913a2">&#9670;&#160;</a></span>operator[]() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const E &amp; <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回指定位置的引用，提供位置检查，实际由at方法实现 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>位置 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad40c6b217d7b63432343d7fcbd681b5f" name="ad40c6b217d7b63432343d7fcbd681b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40c6b217d7b63432343d7fcbd681b5f">&#9670;&#160;</a></span>pop_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>移除末尾元素（不释放容量） </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classshed__std_1_1_eexception.html">Eexception</a></td><td>当Vvector为空时抛出异常 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad40c6b217d7b63432343d7fcbd681b5f" name="ad40c6b217d7b63432343d7fcbd681b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40c6b217d7b63432343d7fcbd681b5f">&#9670;&#160;</a></span>pop_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>元素大小-1，不会自动缩小容量 </p>

</div>
</div>
<a id="ace27eda10aa4ead8ee5165c2f6d4f274" name="ace27eda10aa4ead8ee5165c2f6d4f274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace27eda10aa4ead8ee5165c2f6d4f274">&#9670;&#160;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在末尾添加元素 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>要添加的元素值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classshed__std_1_1_eexception.html">Eexception</a></td><td>当Vvector已达到MAX_SIZE时抛出异常；扩容失败时也可能抛出异常 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace27eda10aa4ead8ee5165c2f6d4f274" name="ace27eda10aa4ead8ee5165c2f6d4f274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace27eda10aa4ead8ee5165c2f6d4f274">&#9670;&#160;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const E &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在末尾添加元素 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>值 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0d40ade3d14003cb90ed272690ddfb7" name="ae0d40ade3d14003cb90ed272690ddfb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d40ade3d14003cb90ed272690ddfb7">&#9670;&#160;</a></span>rbegin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector_iterator <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取指向最后一个元素的反向起始迭代器 </p><dl class="section return"><dt>Returns</dt><dd>反向起始迭代器 </dd></dl>

</div>
</div>
<a id="a08c3bd7ebdcec23171c79d7f5f43370d" name="a08c3bd7ebdcec23171c79d7f5f43370d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c3bd7ebdcec23171c79d7f5f43370d">&#9670;&#160;</a></span>rbegin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a> <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回指向结尾的反向迭代器 </p><dl class="section return"><dt>Returns</dt><dd>指向结尾的反向迭代器 </dd></dl>

</div>
</div>
<a id="a4e1c544f6f8f442a5a315830064f6fda" name="a4e1c544f6f8f442a5a315830064f6fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1c544f6f8f442a5a315830064f6fda">&#9670;&#160;</a></span>rbegin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector_const_iterator <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取指向最后一个元素的反向起始常量迭代器 </p><dl class="section return"><dt>Returns</dt><dd>反向起始常量迭代器 </dd></dl>

</div>
</div>
<a id="a10c80facb548f934ee24010b940e66df" name="a10c80facb548f934ee24010b940e66df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c80facb548f934ee24010b940e66df">&#9670;&#160;</a></span>rbegin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a> <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回指向结尾的常量反向迭代器 </p><dl class="section return"><dt>Returns</dt><dd>指向结尾的常量反向迭代器 </dd></dl>

</div>
</div>
<a id="adac54fd5fa967030178615206333e5a7" name="adac54fd5fa967030178615206333e5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac54fd5fa967030178615206333e5a7">&#9670;&#160;</a></span>rend() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector_iterator <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取指向第一个元素前一位的反向末尾迭代器 </p><dl class="section return"><dt>Returns</dt><dd>反向末尾迭代器 </dd></dl>

</div>
</div>
<a id="a6f5d2f0bdab2ca31bba9168458e7dea3" name="a6f5d2f0bdab2ca31bba9168458e7dea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5d2f0bdab2ca31bba9168458e7dea3">&#9670;&#160;</a></span>rend() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__iterator.html">Vvector_iterator</a> <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回指向开头的反向迭代器 </p><dl class="section return"><dt>Returns</dt><dd>指向开头的反向迭代器 </dd></dl>

</div>
</div>
<a id="a1adab36dc43676eee2cd06cf7f61a228" name="a1adab36dc43676eee2cd06cf7f61a228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adab36dc43676eee2cd06cf7f61a228">&#9670;&#160;</a></span>rend() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::Vvector_const_iterator <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取指向第一个元素前一位的反向末尾常量迭代器 </p><dl class="section return"><dt>Returns</dt><dd>反向末尾常量迭代器 </dd></dl>

</div>
</div>
<a id="a995eae276caa504e341bea44d2522772" name="a995eae276caa504e341bea44d2522772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995eae276caa504e341bea44d2522772">&#9670;&#160;</a></span>rend() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector_1_1_vvector__const__iterator.html">Vvector_const_iterator</a> <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回指向开头的常量反向迭代器 </p><dl class="section return"><dt>Returns</dt><dd>指向开头的常量反向迭代器 </dd></dl>

</div>
</div>
<a id="ab16b792368b32dc9b41f5f6efbada191" name="ab16b792368b32dc9b41f5f6efbada191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16b792368b32dc9b41f5f6efbada191">&#9670;&#160;</a></span>reserve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>预留至少能容纳指定大小的容量（容量保持为2的幂次） </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>所需容纳的元素个数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classshed__std_1_1_eexception.html">Eexception</a></td><td>当size为负数或超过MAX_CAPACITY时抛出异常 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab16b792368b32dc9b41f5f6efbada191" name="ab16b792368b32dc9b41f5f6efbada191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16b792368b32dc9b41f5f6efbada191">&#9670;&#160;</a></span>reserve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>预留至少能容纳size的容量,容量依旧为2的幂次,当当前容量可以满足需求时，不会做任何事 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>大小 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c17874e92863564839ef8c7a1f51133" name="a8c17874e92863564839ef8c7a1f51133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c17874e92863564839ef8c7a1f51133">&#9670;&#160;</a></span>reverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将Vvector中的元素逆序排列 </p>

</div>
</div>
<a id="a8c17874e92863564839ef8c7a1f51133" name="a8c17874e92863564839ef8c7a1f51133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c17874e92863564839ef8c7a1f51133">&#9670;&#160;</a></span>reverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将整个容器逆序 </p>

</div>
</div>
<a id="af6d96ae85b65a44713455b92d33ac523" name="af6d96ae85b65a44713455b92d33ac523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d96ae85b65a44713455b92d33ac523">&#9670;&#160;</a></span>shrink_to_fit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>缩减容量至适合当前大小的2的幂次（当容量大于所需时） </p>

</div>
</div>
<a id="af6d96ae85b65a44713455b92d33ac523" name="af6d96ae85b65a44713455b92d33ac523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d96ae85b65a44713455b92d33ac523">&#9670;&#160;</a></span>shrink_to_fit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>缩小内存，但是容量还是2的幂次，当无法压缩时，不会抛出异常 </p>

</div>
</div>
<a id="a160da0dcb165bd9d9ad55087475bf058" name="a160da0dcb165bd9d9ad55087475bf058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160da0dcb165bd9d9ad55087475bf058">&#9670;&#160;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取当前Vvector的大小（与length()功能相同） </p><dl class="section return"><dt>Returns</dt><dd>元素个数 </dd></dl>

</div>
</div>
<a id="a160da0dcb165bd9d9ad55087475bf058" name="a160da0dcb165bd9d9ad55087475bf058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160da0dcb165bd9d9ad55087475bf058">&#9670;&#160;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回大小,这个函数和length相同 </p><dl class="section return"><dt>Returns</dt><dd>Vvector的大小 </dd></dl>

</div>
</div>
<a id="a7c899c416ab879141ad7880ece3b269c" name="a7c899c416ab879141ad7880ece3b269c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c899c416ab879141ad7880ece3b269c">&#9670;&#160;</a></span>subVec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt; <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::subVec </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取子Vvector（[start_index, end_index)范围内的元素） </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>起始索引（包含） </td></tr>
    <tr><td class="paramname">end_index</td><td>结束索引（不包含） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含指定范围元素的新Vvector对象 </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classshed__std_1_1_eexception.html">Eexception</a></td><td>当范围不合法时抛出异常 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a503bdd48ff4e66295b053fc344e78ebe" name="a503bdd48ff4e66295b053fc344e78ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503bdd48ff4e66295b053fc344e78ebe">&#9670;&#160;</a></span>subVec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classshed__std_1_1_vvector.html">Vvector</a> <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::subVec </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>获取子Vvector,区间[start_index,end_index) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>开始的位置 </td></tr>
    <tr><td class="paramname">end_index</td><td>结束的位置 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>子Vvector </dd></dl>

</div>
</div>
<a id="a7aba8c57e573bc7464fbede3b710f065" name="a7aba8c57e573bc7464fbede3b710f065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aba8c57e573bc7464fbede3b710f065">&#9670;&#160;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::swap </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>交换两个指定索引位置的元素 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index1</td><td>第一个元素的索引 </td></tr>
    <tr><td class="paramname">index2</td><td>第二个元素的索引 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>若索引不合法或相同，则不执行交换操作 </dd></dl>

</div>
</div>
<a id="a7aba8c57e573bc7464fbede3b710f065" name="a7aba8c57e573bc7464fbede3b710f065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aba8c57e573bc7464fbede3b710f065">&#9670;&#160;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classshed__std_1_1_vvector.html">shed_std::Vvector</a>&lt; E &gt;::swap </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>交换两个元素的值 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index1</td><td>元素下标1 </td></tr>
    <tr><td class="paramname">index2</td><td>元素下标2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_vvector_8h_source.html">Vvector.h</a></li>
<li><b>Vvector1.cpp</b></li>
<li><a class="el" href="_vvector_8cpp_source.html">Vvector.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>shed_std</b></li><li class="navelem"><a href="classshed__std_1_1_vvector.html">Vvector</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
